using Bloodcraft.Resources;
using Bloodcraft.Services;
using Bloodcraft.Utilities;
using Il2CppInterop.Runtime;
using ProjectM;
using ProjectM.Network;
using ProjectM.Scripting;
using ProjectM.Shared.WarEvents;
using Stunlock.Core;
using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;
using Unity.Transforms;

namespace Bloodcraft.Systems;
public class PrimalWarEventSystem : SystemBase
{
    public static PrimalWarEventSystem Instance { get; set; }
    static ServerGameManager _serverGameManager;
    static class Constants
    {
        public const int UNIT_LEVELS = 10;
        public const int BOSS_LEVELS = 15;

        public const float MID_AMP = 1.5f;
        public const float HIGH_AMP = 2f;
        public const float HEALTH_AMP = 3f;

        public const float BUFF_CHANCE = 0.1f;
        public const float HIGH_FREQ = 0.025f;
        public const float MID_FREQ = 0.0125f;
        public const float LOW_FREQ = 0.00625f;
        public const float WEIGHT = 0.25f;

        public const float GATE_HEIGHT = 4f;
        public const float RADIUS = 10f;
    }

    static readonly PrefabGUID _primalGate = PrefabGUIDs.UC_WarEvent_Legion_Bosses_Primal;
    static readonly PrefabGUID _primalPortal = PrefabGUIDs.UC_WarEvent_Legion_Smallwaves_Primal;
    static readonly PrefabGUID _bloodRainBuff = PrefabGUIDs.AB_Dracula_Final_TravelToCenter_Normal_BloodRainBuff;

    static readonly List<PrefabGUID> _variantBuffs =
    [
        PrefabGUIDs.Shared_Affix_LevelAura_Self,
        PrefabGUIDs.AB_CastleMan_HolyBeam_PowerBuff_01,
        PrefabGUIDs.AB_Chaos_PowerSurge_Buff,
        PrefabGUIDs.AB_Bandit_Foreman_BloodRage_Buff,
        PrefabGUIDs.AB_BloodBuff_Corruption_Tier3
    ];

    readonly List<GateHazards> _randomThrows =
    [
        new(PrefabGUIDs.AB_LightningStorm_Throw, PrefabGUIDs.AB_LightningStorm_Throw_Big, Constants.HIGH_FREQ),
        new(PrefabGUIDs.AB_Chaos_RainOfChaos_Throw_Meteor, PrefabGUIDs.AB_Chaos_RainOfChaos_Throw_Meteor_Center, Constants.HIGH_FREQ),
        new(PrefabGUIDs.AB_Bandit_StoneBreaker_MountainRumbler_Hard_AreaThrow, PrefabGUIDs.AB_Manticore_BreathFromAbove_Throw, Constants.MID_FREQ),
        new(PrefabGUIDs.AB_Blackfang_ValyrCauldron_Errupt_Throw, PrefabGUIDs.AB_ChurchOfLight_Sommelier_BarrelMinion_Throw02, Constants.MID_FREQ),
        new(PrefabGUIDs.AB_Manticore_FrostVortex_Throw, PrefabGUIDs.AB_Monster_LightningStorm_Throw, Constants.LOW_FREQ),
        new(PrefabGUIDs.AB_Vampire_BloodKnight_SummonCrimsonMaiden_Throw, PrefabGUIDs.AB_Vampire_BloodKnight_FieldOfSpears_Throw, Constants.MID_FREQ),
    ];

    readonly struct GateHazards(PrefabGUID primary, PrefabGUID secondary, float frequency, float weight = Constants.WEIGHT)
    {
        public readonly PrefabGUID Primary { get; } = primary;
        public readonly PrefabGUID Secondary { get; } = secondary;
        public readonly float Frequency { get; } = frequency;
        public readonly float Weight { get; } = weight;
        public void TrySpawnThrow(float3 position)
        {
            if (UnityEngine.Random.value < Frequency)
                WeightedThrow(position);
        }
        void WeightedThrow(float3 center)
        {
            PrefabGUID prefabGuid = UnityEngine.Random.value < Weight ? Secondary : Primary;
            float3 position = center + new float3(
                UnityEngine.Random.Range(-Constants.RADIUS, Constants.RADIUS),
                -Constants.GATE_HEIGHT,
                UnityEngine.Random.Range(-Constants.RADIUS, Constants.RADIUS)
            );

            Entity spawnedThrow = _serverGameManager.InstantiateEntityImmediate(Entity.Null, prefabGuid);
            spawnedThrow.SetPosition(position);
        }
    }

    static readonly ComponentType[] _eventComponents =
    [
        ComponentType.ReadOnly(Il2CppType.Of<WarEvent_StartEvent>()),
        ComponentType.ReadOnly(Il2CppType.Of<FromCharacter>()),
        ComponentType.ReadOnly(Il2CppType.Of<NetworkEventType>())
    ];

    static int PrimalRifts { get; } = ConfigService.PrimalRiftFrequency;
    static double RiftInterval { get; } = PrimalRifts > 0
        ? 86400.0 / PrimalRifts
        : 0;

    double _nextRiftTime = double.MaxValue;
    static bool _isEdited;

    EntityQuery _gateQuery;
    EntityQuery _portalQuery;

    ComponentLookup<VBloodUnit> _vBloodLookup;
    internal ComponentLookup<Translation> _translationLookup;

    ComponentTypeHandle<WarEvent_ActiveGate> _gateHandle;
    ComponentTypeHandle<WarEvent_ActivePortal> _portalHandle;
    BufferTypeHandle<WarEvent_ActiveUnit> _unitBufferHandle;

    EntityTypeHandle _entityHandle;
    EntityStorageInfoLookup _entityStorageInfoLookup;

    NativeParallelHashSet<Entity> _handled;
    public override void OnCreate()
    {
        Instance = this;

        _gateQuery = GetEntityQuery(new EntityQueryDesc
        {
            All = new[]
            {
                ComponentType.ReadOnly(Il2CppType.Of<WarEvent_ActiveGate>()),
                ComponentType.ReadOnly(Il2CppType.Of<WarEvent_ActiveUnit>())
            },
            Options = EntityQueryOptions.IncludeDisabled
        });

        _portalQuery = GetEntityQuery(new EntityQueryDesc
        {
            All = new[]
            {
                ComponentType.ReadOnly(Il2CppType.Of<WarEvent_ActivePortal>()),
                ComponentType.ReadOnly(Il2CppType.Of<WarEvent_ActiveUnit>())
            },
            Options = EntityQueryOptions.IncludeDisabled
        });

        _vBloodLookup = GetComponentLookup<VBloodUnit>(true);
        _translationLookup = GetComponentLookup<Translation>(true);

        _gateHandle = GetComponentTypeHandle<WarEvent_ActiveGate>(true);
        _portalHandle = GetComponentTypeHandle<WarEvent_ActivePortal>(true);
        _unitBufferHandle = GetBufferTypeHandle<WarEvent_ActiveUnit>(true);

        _entityHandle = GetEntityTypeHandle();
        _entityStorageInfoLookup = GetEntityStorageInfoLookup();

        _handled = new NativeParallelHashSet<Entity>(512, Allocator.Persistent);

        RequireForUpdate(_gateQuery);
        RequireForUpdate(_portalQuery);
        Enabled = true;
    }
    public override void OnStartRunning()
    {
        if (!_isEdited) _isEdited = TryModifyPrimalUnitCompositions();
        StartOrScheduleWarEvent();
    }
    void StartOrScheduleWarEvent()
    {
        if (_nextRiftTime == double.MaxValue) _nextRiftTime = _serverGameManager.ServerTime + RiftInterval;
        else if (_serverGameManager.ServerTime >= _nextRiftTime)
        {
            StartPrimalWarEvent();
            _nextRiftTime = _serverGameManager.ServerTime + RiftInterval;
        }
    }
    bool TryModifyPrimalUnitCompositions()
    {
        _serverGameManager = World.GetExistingSystemManaged<ServerScriptMapper>().GetServerGameManager();

        bool wavesModified = false;
        bool soulsModified = false;

        Entity primalWaves = _serverGameManager.GetPrefabEntity(PrefabGUIDs.UC_WarEvent_Legion_Smallwaves_Primal);
        Entity majorWaves = _serverGameManager.GetPrefabEntity(PrefabGUIDs.UC_WarEvent_Legion_Smallwaves_Major);

        Entity primalSouls = _serverGameManager.GetPrefabEntity(PrefabGUIDs.UC_WarEvent_Legion_Bosses_Primal);
        Entity majorSouls = _serverGameManager.GetPrefabEntity(PrefabGUIDs.UC_WarEvent_Legion_Bosses_Major);

        if (_serverGameManager.TryGetBuffer<UnitCompositionGroupEntry>(primalWaves, out var targetBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupUnitEntry>(primalWaves, out var targetUnitBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupEntry>(majorWaves, out var sourceBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupUnitEntry>(majorWaves, out var sourceUnitBuffer))
        {
            targetBuffer.Clear();
            targetBuffer.CopyFrom(sourceBuffer);

            targetUnitBuffer.Clear();
            targetUnitBuffer.CopyFrom(sourceUnitBuffer);

            /*
            for (int i = 0; i < targetBuffer.Length; i++)
            {
                var group = targetBuffer[i];
                group.UnitsCount += 5;
                targetBuffer[i] = group;
            }
            */

            wavesModified = true;
        }

        if (_serverGameManager.TryGetBuffer<UnitCompositionGroupEntry>(primalSouls, out targetBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupUnitEntry>(primalSouls, out targetUnitBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupEntry>(majorSouls, out sourceBuffer)
            && _serverGameManager.TryGetBuffer<UnitCompositionGroupUnitEntry>(majorSouls, out sourceUnitBuffer))
        {
            targetBuffer.Clear();
            targetBuffer.CopyFrom(sourceBuffer);

            targetUnitBuffer.Clear();
            targetUnitBuffer.CopyFrom(sourceUnitBuffer);

            /*
            for (int i = 0; i < targetBuffer.Length; i++)
            {
                var group = targetBuffer[i];
                group.UnitsCount++;
                targetBuffer[i] = group;
            }
            */

            soulsModified = true;
        }

        return wavesModified && soulsModified;
    }
    public override void OnUpdate()
    {
        _vBloodLookup.Update(this);
        _translationLookup.Update(this);

        _gateHandle.Update(this);
        _portalHandle.Update(this);
        _unitBufferHandle.Update(this);

        _entityHandle.Update(this);
        _entityStorageInfoLookup.Update(this);

        SweepHandled();
        StartOrScheduleWarEvent();

        HandleActiveGates(_gateQuery);
        HandleActivePortals(_portalQuery);
    }
    void HandleActiveGates(EntityQuery query)
    {
        var chunks = query.ToArchetypeChunkArray(Allocator.Temp);

        try
        {
            foreach (var chunk in chunks)
            {
                var gates = chunk.GetNativeArray(_gateHandle);
                var unitBuffers = chunk.GetBufferAccessor(_unitBufferHandle);
                var entities = chunk.GetNativeArray(_entityHandle);

                for (int i = 0; i < chunk.Count; ++i)
                {
                    WarEvent_ActiveGate activeGate = gates[i];
                    Entity entity = entities[i];

                    if (!activeGate.UnitComposition.Equals(_primalGate)) continue;

                    var buffer = unitBuffers[i];
                    bool isActive = false;

                    foreach (var activeUnit in buffer)
                    {
                        Entity unitEntity = activeUnit.Instance;
                        bool isGateBoss = _vBloodLookup.HasComponent(unitEntity);

                        if (!_entityStorageInfoLookup.Exists(unitEntity)) continue;
                        else if (_handled.Contains(unitEntity))
                        {
                            isActive = true;
                            continue;
                        }

                        if (isGateBoss) unitEntity.TryApplyBuffWithLifeTimeNone(_bloodRainBuff);
                        // unitEntity.TryApplyBuffWithLifeTimeNone(_variantBuffs.DrawRandom());
                        Core.RunDelayed(() => unitEntity.TryApplyBuffWithLifeTimeNone(_variantBuffs.DrawRandom()));
                        ModifyPrimalUnit(unitEntity, isGateBoss);

                        isActive = true;
                        _handled.Add(unitEntity);
                    }

                    if (!isActive || _translationLookup.TryGetComponent(entity, out Translation translation)) continue;

                    GateHazards hazards = _randomThrows.DrawRandom();
                    hazards.TrySpawnThrow(translation.Value);
                }
            }
        }
        catch (Exception e)
        {
            Core.Log.LogError($"[PrimalWarEventSystem.HandleActiveGates] Exception: {e}");
        }
        finally
        {
            chunks.Dispose();
        }
    }
    void HandleActivePortals(EntityQuery query)
    {
        var chunks = query.ToArchetypeChunkArray(Allocator.Temp);

        try
        {
            foreach (var chunk in chunks)
            {
                var portals = chunk.GetNativeArray(_portalHandle);
                var unitBuffers = chunk.GetBufferAccessor(_unitBufferHandle);
                var entities = chunk.GetNativeArray(_entityHandle);

                for (int i = 0; i < chunk.Count; ++i)
                {
                    WarEvent_ActivePortal activePortal = portals[i];
                    Entity entity = entities[i];

                    if (!activePortal.UnitComposition.Equals(_primalPortal))
                        continue;

                    // activePortal.MinNormalUnits = 15;
                    // activePortal.ThrashPerNormal = 5;
                    // didn't seem to do anything, may need to add to unit composition numbers first

                    var buffer = unitBuffers[i];
                    bool isActive = false;

                    foreach (var activeUnit in buffer)
                    {
                        Entity unitEntity = activeUnit.Instance;

                        if (!_entityStorageInfoLookup.Exists(unitEntity)) continue;
                        else if (_handled.Contains(unitEntity))
                        {
                            isActive = true;
                            continue;
                        }

                        if (Misc.RollForChance(Constants.BUFF_CHANCE))
                        {
                            Core.RunDelayed(() => unitEntity.TryApplyBuffWithLifeTimeNone(_variantBuffs.DrawRandom()));
                        }

                        ModifyPrimalUnit(unitEntity);

                        isActive = true;
                        _handled.Add(unitEntity);
                    }

                    if (!isActive || _translationLookup.TryGetComponent(entity, out Translation translation)) continue;

                    GateHazards hazards = _randomThrows.DrawRandom();
                    hazards.TrySpawnThrow(translation.Value);
                }
            }
        }
        catch (Exception e)
        {
            Plugin.LogInstance.LogError($"[PrimalWarEventSystem.HandleActivePortals] Exception: {e}");
        }
        finally
        {
            chunks.Dispose();
        }
    }
    void SweepHandled()
    {
        var units = _handled.ToNativeArray(Allocator.Temp);

        foreach (var unit in units)
        {
            if (!_entityStorageInfoLookup.Exists(unit))
            {
                _handled.Remove(unit);
            }
        }

        units.Dispose();
    }
    static void ModifyPrimalUnit(Entity entity, bool isGateBoss = false)
    {
        SetLevel(entity, isGateBoss);
        SetAttackSpeed(entity, isGateBoss);
        SetHealth(entity, isGateBoss);
        SetPower(entity, isGateBoss);
        SetMoveSpeed(entity);
    }
    static void SetLevel(Entity entity, bool isGateBoss)
    {
        int modifier = isGateBoss ? Constants.BOSS_LEVELS : Constants.UNIT_LEVELS;

        entity.With((ref UnitLevel unitLevel) => unitLevel.Level._Value += modifier);
    }
    static void SetAttackSpeed(Entity entity, bool isGateBoss)
    {
        // float modifier = isGateBoss ? HIGH_AMP : MID_AMP;

        entity.With((ref AbilityBar_Shared abilityBarShared) =>
        {
            abilityBarShared.AbilityAttackSpeed._Value *= Constants.HIGH_AMP;
            abilityBarShared.PrimaryAttackSpeed._Value *= Constants.HIGH_AMP;
        });
    }
    static void SetHealth(Entity entity, bool isGateBoss)
    {
        // float modifier = isGateBoss ? HIGH_AMP : MID_AMP;

        entity.With((ref Health health) =>
        {
            health.MaxHealth._Value *= Constants.HEALTH_AMP;
            health.Value = health.MaxHealth._Value;
        });
    }
    static void SetPower(Entity entity, bool isGateBoss)
    {
        // float modifier = isGateBoss ? HIGH_AMP : MID_AMP;

        entity.With((ref UnitStats unitStats) =>
        {
            unitStats.PhysicalPower._Value *= Constants.HIGH_AMP;
            unitStats.SpellPower._Value *= Constants.HIGH_AMP;
            unitStats.FireResistance._Value = isGateBoss ? 1 : unitStats.FireResistance._Value;
        });

        if (isGateBoss)
        {
            entity.HasWith((ref ResistanceData resistanceData) =>
            {
                resistanceData.FireResistance_DamageReductionPerRating = 100f;
                resistanceData.FireResistance_RedcuedIgiteChancePerRating = 100f;
            });
        }
    }
    static void SetMoveSpeed(Entity entity)
    {
        entity.With((ref AiMoveSpeeds aiMoveSpeeds) =>
        {
            aiMoveSpeeds.Walk._Value *= Constants.MID_AMP;
            aiMoveSpeeds.Run._Value *= Constants.MID_AMP;
            aiMoveSpeeds.Circle._Value *= Constants.MID_AMP;
        });
    }
    public static void StartPrimalWarEvent()
    {
        if (PlayerService.SteamIdOnlinePlayerInfoCache.Count == 0)
        {
            Core.Log.LogWarning("[PrimalWarEventSystem] No players online to start primal war event...");
            return;
        }

        var player = PlayerService.SteamIdOnlinePlayerInfoCache.Values.First();
        if (!player.UserEntity.Exists() || !player.CharEntity.Exists()) return;

        NetworkEventType networkEventType = new()
        {
            EventId = NetworkEvents.EventId_WarEvent_StartEvent,
            IsAdminEvent = true,
            IsDebugEvent = true
        };

        WarEvent_StartEvent warEvent = new()
        {
            EventType = WarEventType.Primal,
            EnableAllGates = true
        };

        FromCharacter fromCharacter = new()
        {
            Character = player.CharEntity,
            User = player.UserEntity
        };

        Entity entity = Core.EntityManager.CreateEntity(_eventComponents);
        entity.Write(warEvent);
        entity.Write(fromCharacter);
        entity.Write(networkEventType);
    }

    /*
    public static void AddUnitToCompEnd(PrefabGUID prefabGuid)
    {
        var unitBuffer = entityManager.GetBuffer<UnitCompositionGroupUnitEntry>(ucEntity);
        var groupBuffer = entityManager.GetBuffer<UnitCompositionGroupEntry>(ucEntity);

        unitBuffer.Add(new UnitCompositionGroupUnitEntry
        {
            Unit = unitGuid,
            IsVBloodUnit = false,
            CustomVBloodUnit = default,
            // UnitBaseStatsType = UnitBaseStatsType.Normal
        });

        var last = groupBuffer.Length--;
        var entry = groupBuffer[last];

        entry.UnitsCount++;
        groupBuffer[last] = entry;
    }
    */
}
